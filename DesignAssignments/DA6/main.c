/*
 * DA6.c
 *
 * Created: 5/12/2019 10:16:10 PM
 * Author : Ali Asadi
 */ 

#include <stdlib.h>
#include <stdio.h>
#include <inttypes.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>
#include <String.h>
#include <util/delay.h>
#include "i2c.h"
#include "MPU6050_def.h"
#define MPU6050_WRITE 0xD0
#define MPU6050_READ 0xD1

void USART_init();
void USART_send(char );
void sendString(const char *);
void init_MPU6050();
int getreading(uint8_t);

int main()
{
  float value;
  char buffer[20], float_[10];
  USART_init();     // initialize USART
  i2c_init();       // initialize I2C
  init_MPU6050();   // initialize MPU6050
  while (1)
  {
    // Accelerometer Reading 
    value = getreading(ACCEL_XOUT_H) / 16384.0; /* Divide raw value by sensitivity scale factor to get real values */
    dtostrf(value, 3, 2, float_ );/* Take values in buffer to send all parameters over USART */
    sprintf(buffer, "%s, ", float_);
    sendString(buffer);

    value = getreading(ACCEL_YOUT_H) / 16384.0; /* Divide raw value by sensitivity scale factor to get real values */
    dtostrf(value, 3, 2, float_ );/* Take values in buffer to send all parameters over USART */
    sprintf(buffer, "%s, ", float_);
    sendString(buffer);

    value = getreading(ACCEL_ZOUT_H) / 16384.0; /* Divide raw value by sensitivity scale factor to get real values */
    dtostrf(value, 3, 2, float_ );/* Take values in buffer to send all parameters over USART */
    sprintf(buffer, "%s, ", float_);
    sendString(buffer);
     
    // Gyroscope Reading 
    value = getreading(GYRO_XOUT_H) / 131.0; /* Divide raw value by sensitivity scale factor to get real values */
    dtostrf(value, 3, 2, float_ );/* Take values in buffer to send all parameters over USART */
    sprintf(buffer, "%s, ", float_);
    sendString(buffer);

    value = getreading(GYRO_YOUT_H) / 131.0; /* Divide raw value by sensitivity scale factor to get real values */
    dtostrf(value, 3, 2, float_ );/* Take values in buffer to send all parameters over USART */
    sprintf(buffer, "%s, ", float_);
    sendString(buffer);

    value = getreading(GYRO_ZOUT_H) / 131.0; /* Divide raw value by sensitivity scale factor to get real values */
    dtostrf(value, 3, 2, float_ );/* Take values in buffer to send all parameters over USART */
    sprintf(buffer, "%s,\n\r", float_);
    sendString(buffer);

    _delay_ms(1000);
  }
  return 0;
}

void USART_init()
{
  UCSR0B = 0x18;         // TX enable
  UCSR0C = 0x06;         // 8 bit data
  UBRR0L = 8;           // Baud Rate 115200
}

void init_MPU6050(void) {
  _delay_ms(150);										/* Power up time >100ms */
  i2c_start(MPU6050_WRITE); // Set Gyroscope Sample Rate = 1 KHz, Accelerometer Sample Rate = 1 KHz (default)
  i2c_write(SMPLRT_DIV); // Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV
  i2c_write(0x07); // Gyroscope Output Rate = 8kHz, Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
  i2c_stop();

  i2c_start(MPU6050_WRITE);
  i2c_write(PWR_MGMT_1);
  i2c_write(0x01); // PLL with X axis gyroscope reference
  i2c_stop();

  i2c_start(MPU6050_WRITE);
  i2c_write(CONFIG); //Frame Synchronization & Digital Low Pass Filter (DLPF) setting
  i2c_write(0x00);
  i2c_stop();

  i2c_start(MPU6050_WRITE);
  i2c_write(GYRO_CONFIG); //gyroscopes� scale range = FS_SEL selects = 11 = � 2000 �/s
  i2c_write(0x18);		// accelerometer range = � 2g (default)
  i2c_stop();

  i2c_start(MPU6050_WRITE);
  i2c_write(INT_ENABLE); // DATA_RDY_EN = 1
  i2c_write(0x01);
  i2c_stop();
}

int getreading(uint8_t Register) {

  int reading;
  i2c_start(MPU6050_WRITE);
  i2c_write(Register); // set pointer
//  i2c_stop();
  
  i2c_start(MPU6050_READ);
  reading = (((int)i2c_read_ack() << 8) | (int)i2c_read_nack());
  i2c_stop();
  return  reading;
}

void USART_send(char data)
{
  while (!(UCSR0A & _BV(UDRE0))); // check if the Data register is empty
  UDR0 = data;           // send the data
}

void sendString(const char *str)
{
  while (*str)           // send all the data till null Character
    USART_send(*str++);
}

char USART_Receive()
{
  while (!(UCSR0A & _BV(RXC0))); // wait for character in receiver
  return UDR0;
}
